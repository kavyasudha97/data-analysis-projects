/*## QUESTION 1:  Exploring a `LEFT JOIN` using the `books` and `to_read` tables

The code block below has been commented out. To answer this question, you will need to uncomment it by removing the `/*` (line 1) and `*/` (line 16).

**Part A:** Look at Query 1, which table is the 'Left' table and which is the 'Right'?
*/
--Query 1: LEFT JOIN
SELECT TOP 50 b.title, b.average_rating, b.books_count,tr.user_id, tr.book_id
FROM BooksDB.dbo.books AS b
LEFT JOIN BooksDB.dbo.to_read AS tr
ON b.best_book_id = tr.book_id
ORDER BY b.average_rating;

--Answer: b is the left table and tr is the right table

/*-- Query 2: LEFT JOIN USING 'IS NOT NULL'*/
SELECT TOP 50 b.title, b.average_rating, b.books_count,tr.user_id, tr.book_id
FROM BooksDB.dbo.books AS b
LEFT JOIN BooksDB.dbo.to_read AS tr
ON b.best_book_id = tr.book_id
WHERE tr.user_id IS NOT NULL
ORDER BY b.average_rating;

/* Answer: by executing this command it showed the values those are not null.
 The reason is here we have given where condition for tr table where tr.user_id IS NOT NULL.*/

/*## **QUESTION 2:** Exploring `RIGHT` joins with the `books` and `to_read` tables

You will need to uncomment the query to answer the question.

**Part A:** Looking at the query, which table is the 'Left' and which is the 'Right'?*/
-- Query 1: RIGHT JOIN
SELECT TOP 300 b.title, b.average_rating, b.books_count, tr.user_id, tr.book_id
FROM BooksDB.dbo.books AS b
RIGHT JOIN BooksDB.dbo.to_read AS tr
ON b.best_book_id = tr.book_id;

-- answer: b table is the left table and tr is the right table.

/***Part B:** How do the RIGHT-joined tables differ from the LEFT-joined tables in Question 1?*/

-- Answer: This had taken the common rows from the two tables and gave null values for the unmatched rows.

/*## **QUESTION 3:** Exploring FULL JOINS with the `books` and `to_read` tables

You will need to uncomment the Query to answer the question.

**Part A:**  Look at the table and explore how it was populated.  Try manipulating the query to better understand how this table works.  
Try adding a WHERE clause, or ORDER BY a column on the `books` table.  Based on your exploration, can you think of when you might want a FULL join rather than a LEFT, RIGHT, or INNER?*/


-- INNER JOIN
SELECT TOP 30 b.title, b.average_rating, b.books_count,tr.user_id, tr.book_id
FROM BooksDB.dbo.books AS b
INNER JOIN BooksDB.dbo.to_read AS tr
ON b.book_id = tr.book_id
WHERE b.title IS NOT NULL
ORDER BY tr.book_id;

-- Answer: This is giving all the rows the are common with the two tables avoiding the the title that has null vales.

/* ## **QUESTION 4:** Exploring INNER Joins with the `books` and `to_read` tables

You will need to uncomment the Query to answer the question.*/

--**Part A:**  What does an inner join do?
--**Part B:** Currently this table has an `'IS NOT NULL'` in the `WHERE` clause. Is this necessary for this table? Why or Why not?
--**Part C:**  When using SQL, you are usually returning much larger tables so every line of code will add to the compilation and return time. 
 --Rewrite this inner join query so that it contains no redundant code.

-- INNER JOIN
SELECT TOP 30 b.title, b.average_rating, b.books_count,tr.user_id, tr.book_id
FROM BooksDB.dbo.books AS b
INNER JOIN BooksDB.dbo.to_read AS tr
ON b.book_id = tr.book_id
WHERE b.title IS NOT NULL
ORDER BY tr.book_id;
 
 --Part A Answer: Inner join gives the rows that are matched in both tables including null values.
 --Part B Answer:  According to this query there is no change between having a where clause and not having a where clause. So, this table doesnot need a where clause.
 --Part C Answer: 
 SELECT TOP 30 b.title, b.average_rating, b.books_count,tr.user_id, tr.book_id
FROM BooksDB.dbo.books AS b
INNER JOIN BooksDB.dbo.to_read AS tr
ON b.book_id = tr.book_id
ORDER BY tr.book_id;


/* ## **QUESTION 5:**  Using joins to find the most tagged book and the most popular tag

We will be writing 3 queries to find both the most tagged book and that book's most popular tag.

**Part A:**  What is the most tagged book?

Start by joining the `books` and `book_tags` tables ON the `books.best_book_id` and `book_tags.goodreads_book_id`.
 We want the *most popular* book, so think about ordering the table in a way that will display both the book title and the number of times a book tag has been used.

Minimum Desired output:_  The title of the most tagged book, and the number of times the book has been tagged.

**Title:** */

select * from dbo.books
select * from dbo.book_tags

select top 1 books.title ,count(book_tags.tag_id) from dbo.books 
join dbo.book_tags on books.best_book_id=book_tags.goodreads_book_id  group by books.title order by count(book_tags.tag_id) DESC


/* **Part B:** How many different tags have been used for the most tagged book?

Start by joining the `books` and `book_tags` tables ON the `books.best_book_id` and `book_tags.goodreads_book_id`. We want to find the *most popular* tag id, so think about ordering in a way that will display the most popular tag id.

*Minimum Desired Output:* The tag id for the most popular tag used for the most tagged book.

**Tag Id:** */
 
SELECT TOP 1 
    book_tags.tag_id,
    COUNT(book_tags.tag_id) AS tag_count
FROM dbo.books 
INNER JOIN BooksDB.dbo.book_tags 
    ON books.best_book_id = book_tags.goodreads_book_id
WHERE books.title = 'selected poems'   
GROUP BY book_tags.tag_id
ORDER BY tag_count DESC;

/* **Part C:** What is this particular tag?

You may return this answer with a simple query.

*Minimum Desired Output:* The tag name for the most popular tag used for the most tagged book.

**Tag Name:** */
select * from dbo.book_tags
select * from dbo.books

SELECT t.tag_name
FROM BooksDB.dbo.tags AS t
WHERE t.tag_id = (
  SELECT TOP 1
    bt.tag_id
  FROM BooksDB.dbo.book_tags AS bt
  WHERE bt.goodreads_book_id = (
    SELECT TOP 1 b2.best_book_id
    FROM BooksDB.dbo.books AS b2
    JOIN BooksDB.dbo.book_tags AS bt2
      ON b2.best_book_id = bt2.goodreads_book_id
    GROUP BY b2.best_book_id
    ORDER BY COUNT(*) DESC
  )
  GROUP BY bt.tag_id
  ORDER BY COUNT(*) DESC
);


/* ## QUESTION 6: Find a book based on a tag of your choice using joins.

Some suggestions: any hobbies you like? baking, drawing, etc. how about favorite holidays, subjects, animals, etc?

**Part A:** Explore the tags table for a tag of your choice.  Suggested ideas, try searching for one of your hobbies, a favorite time of year, favorite animal, etc.  
Start by querying the tag table for your chosen tag.  (_Hint:_ in order to make sure you find all combinations of your tags, use the wildcard).  If your query returns more than one result, pick your favorite.

Here is an example.  Alyce wanted to search for Halloween books.  She used the wildcard, `%halloween%` and 8 different combinations were found.  Alyce selected `halloween-storytime`, with a tag id of 13877.

*Minimum Desired Output:* tag name and tag id

**Your Tag and Tag Id:** */
select * from dbo.tags

select tag_id, tag_name from dbo.tags WHERE tag_name='fiction'

/* **Part B:** Now that you have the tag id, find the title that was tagged the most with this tag by joining the `books` and `books_tags` tables.

Alyce joined the book table with the tags table and discovered that "The Little Old Lady Who Was Not Afraid of Anything" was tagged as `halloween-storytime` the most.

*Minimum Desired Output:* title and tag count

**Your Title and Number of times the tag was used:** */

SELECT TOP 1  books.title, COUNT(book_tags.tag_id) AS count FROM dbo.books 
INNER JOIN dbo.book_tags 
    ON books.best_book_id = book_tags.goodreads_book_id
WHERE book_tags.tag_id = 11743 
GROUP BY books.title
ORDER BY count DESC;

/* ## **QUESTION 7:** What are the top 10 most popular book titles on the 'to read' list?

**Part A:**  Explore how the `to_read` and `books` tables are organized, and then join them.  What will you use as a key?*/
select * from dbo.books
select * from dbo.to_read

-- answer: in both the tables the common column is book_id. we use this column and join the tables.


/* **Part B:** Organize your newly joined table in a way that groups popularity based on the title based on users.

*Hint:* Suggest using an alias for the aggregation you will need to run on the `user_id`

*Minimum Desired Output:* title and aliased column */

select top 10 books.original_title, count(to_read.[user_id]) as 'to-read' from dbo.books 
inner join dbo.to_read on books.book_id = to_read.book_id 
group by books.original_title 
order by 'to-read' DESC

/* ## **QUESTION 8:** Largest 'To Read' Lists

**Part A:**  Create a query that returns a table that contains the top 10 users with the most number of titles on their 'to read' list.    Group all the entries by `user_id`.

_Hint:_ You might want an alias for the titles.

_Minimum Desired Output:_ `user_id` and your aliased column of titles. */

select top 10 to_read.[user_id], count(to_read.book_id) as titles from dbo.to_read 
group by to_read.[user_id] order by titles DESC


/* **Part B:**  The longest list length is 15 titles total, and is shared by 4 different users.  
Select one of the uses and print out their entire 'to read' list. */

select to_read.[user_id], books.title from dbo.to_read
inner join dbo.books on to_read.book_id = books.book_id
where to_read.[user_id]=  46000 
order by books.title